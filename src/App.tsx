import React from 'react';
import { ThemeProvider } from '@emotion/react';
import { ThemeValues } from './theme/ThemeValues';
import { Container } from './components/layout/Container';
import { GoalsSection } from './components/goals-section/GoalsSection';
import { marked } from 'marked';
import './types.d.ts';

const resp = marked(
  "Your roadmap is a good start, but it needs more detail and potentially some re-ordering for optimal learning. Here's a breakdown with suggestions:\n\n**Analysis of your Current Roadmap:**\n\n*   **RxJS:**  Excellent choice. RxJS is crucial for managing asynchronous data streams and events in modern front-end development (especially with Angular, React, and Vue).  Learning this early can greatly simplify complex UI interactions.\n*   **Docker:** Docker is more relevant to the *deployment* and *environment setup* side of things, rather than core front-end development. While valuable, it's better to learn it after you have a solid foundation in the front-end fundamentals. Knowing Docker helps ensure consistency across different environments and simplifies deployment, but it won't directly impact your ability to *build* a user interface.\n*   **Design:**  Design is extremely important!  However, \"learn design\" is very broad. You need to be more specific.  Are you referring to UI design principles, UX design, accessibility, visual design (color theory, typography), or design systems?\n\n**Revised and Expanded Roadmap:**\n\nHere's a more comprehensive and structured roadmap.  I'm breaking it down into phases with recommendations on how to prioritize and learn each topic.\n\n**Phase 1:  Foundational HTML, CSS, and JavaScript**\n\nThis is the absolute MUST. You can't build a front-end without these.\n\n*   **HTML:**\n    *   **Fundamentals:**  Elements, attributes, document structure, semantics.\n    *   **Forms:**  Input types, validation, handling form data.\n    *   **Semantic HTML:**  `<article>`, `<nav>`, `<aside>`, `<header>`, `<footer>`, `<main>`.  Learn how to structure content for accessibility and SEO.\n*   **CSS:**\n    *   **Fundamentals:** Selectors, properties, values, the box model, cascading and specificity.\n    *   **Layout:**  Flexbox, Grid, Positioning (relative, absolute, fixed, sticky).  Media queries for responsive design.\n    *   **Typography:**  Fonts, sizes, line height, letter spacing, text alignment.\n    *   **CSS Preprocessors (Optional, but Recommended):** Sass or LESS.  These make CSS more maintainable and organized.\n*   **JavaScript:**\n    *   **Fundamentals:** Variables, data types, operators, control flow (if/else, loops), functions.\n    *   **DOM Manipulation:**  Selecting elements, modifying content, adding/removing elements, event handling.\n    *   **Asynchronous JavaScript:**  Callbacks, Promises, `async/await`. This is crucial for making API calls and handling asynchronous operations.\n    *   **ES6+ Features:**  `let` and `const`, arrow functions, template literals, destructuring, spread/rest operators, classes, modules.  *These are essential for modern JavaScript development.*\n    *   **Data Structures and Algorithms (Basic):** Understanding arrays, objects, and common algorithms (sorting, searching) will make you a better problem-solver.\n\n**Resources:**\n\n*   **MDN Web Docs:**  The definitive resource for web technologies.\n*   **freeCodeCamp:**  Excellent interactive tutorials and projects.\n*   **Codecademy:**  Another good platform for interactive learning.\n*   **Scrimba:**  Screencasts with interactive code editing.\n*   **Wes Bos (Paid Courses):** JavaScript 30 is a great project-based course.\n\n**Phase 2:  Front-End Framework (React, Angular, or Vue)**\n\nChoose ONE framework to start with.  Don't try to learn them all at once.  React is generally considered a good starting point due to its large community and simpler core concepts.\n\n*   **React:**\n    *   **Components:** Functional components, class components (less common now, but still good to understand).\n    *   **JSX:**  Writing HTML-like syntax in JavaScript.\n    *   **Props:** Passing data from parent to child components.\n    *   **State:** Managing data within a component.  `useState` and `useReducer` hooks.\n    *   **Lifecycle Methods (Class Components - less relevant, but understand the concepts):** `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`.\n    *   **Hooks:** `useState`, `useEffect`, `useContext`, `useRef`, custom hooks.  Hooks are the modern way to manage state and side effects in React.\n    *   **Conditional Rendering:**  Displaying different content based on conditions.\n    *   **List Rendering:**  Rendering arrays of data.\n    *   **Event Handling:**  Handling user interactions.\n    *   **Forms:** Controlled components, uncontrolled components.\n    *   **Routing:**  React Router.\n    *   **State Management (Optional, but often needed for larger applications):**  Redux, Zustand, Recoil.\n*   **Angular:**\n    *   **Components:**  Templates, styles, logic.\n    *   **Modules:** Organizing your application into logical units.\n    *   **Directives:**  Adding custom behavior to elements (e.g., `*ngIf`, `*ngFor`).\n    *   **Services:**  Providing data and logic to components.\n    *   **Dependency Injection:**  Angular's core mechanism for managing dependencies.\n    *   **Routing:**  Angular Router.\n    *   **Forms:**  Template-driven forms, reactive forms.\n    *   **RxJS (Heavily Used):**  Angular relies heavily on RxJS for handling asynchronous data.\n*   **Vue:**\n    *   **Components:**  Templates, scripts, styles.\n    *   **Directives:**  `v-if`, `v-for`, `v-model`.\n    *   **Data Binding:**  Two-way data binding with `v-model`.\n    *   **Computed Properties:**  Deriving values from data.\n    *   **Watchers:**  Responding to data changes.\n    *   **Routing:**  Vue Router.\n    *   **State Management (Optional, but often needed for larger applications):**  Vuex, Pinia.\n\n**Resources:**\n\n*   **React:**  Official React Documentation (excellent), Create React App (for quickly starting new projects), React.dev\n*   **Angular:** Official Angular Documentation, Angular CLI (for generating code and building applications).\n*   **Vue:** Official Vue.js Documentation, Vue CLI.\n\n**Phase 3:  State Management and Asynchronous Data (RxJS)**\n\n*   **RxJS (Essential for Angular, very useful for React and Vue):**\n    *   **Observables:**  Understanding the concept of observables and how they emit values over time.\n    *   **Operators:**  `map`, `filter`, `reduce`, `concat`, `merge`, `switchMap`, `debounceTime`, `throttleTime`.  Learn how to transform and manipulate data streams.\n    *   **Subjects:**  Multicasting values to multiple observers.\n    *   **Schedulers:**  Controlling the timing of observable emissions.\n    *   **Error Handling:**  Handling errors in observable streams.\n*   **State Management Libraries (if not already learned):**\n    *   **Redux (React):**  Centralized state management with a predictable data flow.\n    *   **Zustand (React):** Simplified state management with minimal boilerplate\n    *   **Recoil (React):** Fine-grained state management with an emphasis on data dependencies.\n    *   **Vuex (Vue):**  Centralized state management for Vue applications.\n    *   **Pinia (Vue):** Type safe, easy to use state management for Vue.\n\n**Resources:**\n\n*   **RxJS:**  Official RxJS Documentation, RxJS Marbles (visualizing operators).\n*   **Redux:**  Official Redux Documentation, Redux Toolkit (for simplifying Redux setup).\n*   **Vuex:**  Official Vuex Documentation.\n*   **Zustand:** Official Zustand Documentation\n*   **Pinia:** Official Pinia Documentation\n*   **Recoil:** Official Recoil Documentation\n\n**Phase 4:  Testing**\n\n*   **Unit Testing:**  Testing individual components and functions.\n*   **Integration Testing:**  Testing how different parts of your application work together.\n*   **End-to-End (E2E) Testing:**  Testing the entire application from the user's perspective.\n*   **Testing Libraries:**\n    *   **Jest:**  A popular JavaScript testing framework (often used with React).\n    *   **Mocha:**  Another popular testing framework.\n    *   **Chai:**  An assertion library (often used with Mocha).\n    *   **React Testing Library:**  Focuses on testing components from the user's perspective.\n    *   **Cypress:**  A powerful E2E testing tool.\n    *   **Playwright:** Another E2E testing tool created by Microsoft\n    *   **Karma:** A test runner for Angular\n    *   **Jasmine:** A behavior-driven development framework for testing Javascript code. (Often used with Angular)\n\n**Phase 5:  Backend Communication and APIs**\n\n*   **REST APIs:**  Understanding RESTful principles, HTTP methods (GET, POST, PUT, DELETE), status codes.\n*   **GraphQL:**  An alternative to REST that allows clients to request only the data they need.\n*   **Fetching Data:**\n    *   **`fetch` API:**  The built-in JavaScript API for making HTTP requests.\n    *   **Axios:**  A popular HTTP client library.\n\n**Phase 6:  Build Tools and Optimization**\n\n*   **Package Managers:** npm, yarn, or pnpm.\n*   **Bundlers:**  Webpack, Parcel, Rollup.  Learn how to bundle your code for production.\n*   **Code Splitting:**  Loading only the code that is needed for the current page.\n*   **Minification:**  Reducing the size of your code by removing unnecessary characters.\n*   **Caching:**  Leveraging browser caching to improve performance.\n\n**Phase 7:  Deployment and DevOps (Including Docker)**\n\n*   **Docker:**\n    *   **Containers:**  Understanding the concept of containers.\n    *   **Docker Images:**  Creating and managing Docker images.\n    *   **Dockerfiles:**  Writing Dockerfiles to define your application's environment.\n    *   **Docker Compose:**  Orchestrating multi-container applications.\n*   **Deployment Platforms:**\n    *   **Netlify:**  A popular platform for deploying static sites and front-end applications.\n    *   **Vercel:**  Another great platform for deploying front-end applications.\n    *   **AWS Amplify:**  AWS's platform for building and deploying full-stack applications.\n    *   **Firebase Hosting:**  Google's platform for hosting web applications.\n    *   **Heroku:**  A platform-as-a-service (PaaS).\n*   **CI/CD (Continuous Integration/Continuous Deployment):**\n    *   **GitHub Actions:**  Automating your build, test, and deployment processes.\n    *   **Jenkins:**  A popular open-source CI/CD server.\n\n**Phase 8:  Design Principles, Accessibility, and UI/UX**\n\nThis is where you need to get more specific about \"design.\"\n\n*   **UI Design Principles:**\n    *   **Consistency:**  Using consistent styles and patterns throughout your application.\n    *   **Hierarchy:**  Guiding the user's eye with visual hierarchy.\n    *   **Balance:**  Creating a visually balanced layout.\n    *   **Contrast:**  Using contrast to highlight important elements.\n    *   **White Space:**  Using white space to create a clean and uncluttered layout.\n*   **UX Design Principles:**\n    *   **Usability:**  Making your application easy to use.\n    *   **Accessibility:**  Making your application accessible to people with disabilities (see below).\n    *   **User Research:**  Understanding your users' needs and goals.\n    *   **Information Architecture:**  Organizing your content in a logical and intuitive way.\n*   **Accessibility (WCAG):**\n    *   **Semantic HTML:**  Using semantic HTML elements to structure your content.\n    *   **ARIA Attributes:**  Adding ARIA attributes to improve accessibility for assistive technologies.\n    *   **Keyboard Navigation:**  Ensuring that your application is fully navigable using the keyboard.\n    *   **Color Contrast:**  Using sufficient color contrast for text and other elements.\n    *   **Screen Reader Compatibility:**  Testing your application with a screen reader.\n*   **Visual Design:**\n    *   **Color Theory:**  Understanding color relationships and how to use color effectively.\n    *   **Typography:**  Choosing appropriate fonts and using them effectively.\n    *   **Layout:**  Creating visually appealing and functional layouts.\n    *   **Design Systems:**  Creating reusable UI components and styles to ensure consistency across your application.\n\n**Resources:**\n\n*   **UI Design:**  Dribbble, Behance, UI Patterns.\n*   **UX Design:**  NNGroup, UX Collective.\n*   **Accessibility:**  WCAG (Web Content Accessibility Guidelines),  A11y Project.\n*   **Design Systems:**  Material Design, Ant Design, Atlassian Design System.\n\n**Important Considerations:**\n\n*   **Project-Based Learning:** The MOST important thing is to build projects as you learn.  Start small and gradually increase the complexity.  Don't just read tutorials; *apply* what you learn.\n*   **Practice Consistently:**  Code every day, even if it's just for 30 minutes.\n*   **Join a Community:**  Engage with other developers online (Stack Overflow, Reddit, Discord).  Ask questions and help others.\n*   **Stay Up-to-Date:** The front-end landscape changes rapidly.  Keep learning and adapting.  Follow industry blogs, attend conferences, and read about new technologies.\n*   **Focus:** Don't try to learn everything at once.  Focus on one topic or framework at a time.\n*   **Persistence:**  Learning front-end development takes time and effort.  Don't get discouraged.  Keep practicing and you will improve.\n*   **Version Control:** Use Git and GitHub from the beginning.  Learn how to commit, branch, merge, and collaborate with others.  This is a critical skill.\n\nBy following this expanded roadmap and focusing on project-based learning, you'll be well on your way to becoming a proficient front-end developer.  Good luck!\n"
);
export const App = () => {
  return (
    <ThemeProvider theme={ThemeValues}>
      <Container ratio={60} verticalSpacing={32}>
        <GoalsSection />
      </Container>
    </ThemeProvider>
  );
};
